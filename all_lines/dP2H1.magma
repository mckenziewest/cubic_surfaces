load "backgroundFunctions.magma";

P3<x,y,z,w> := ProjectiveSpace(Rationals(),[1,1,1,2]);

findLines := function(q)
	P2 := ProjectiveSpace(Rationals(),2);
	F := w^2 - q;
	X := Scheme(P3,F);


	/* In order to find the lines which lie on X, we first 
	project down to the first 3 coordinates, forgetting w. 
	We will examine the curve C given by w = 0.  The pullback of 
	the lines which are bitangent to C in P2 contains 2 lines 
	which lie on the surface, X. Every such line is produced in 
	this way.*/
	rest := map< X -> P2 | [x,y,z]>;
	C := rest(X meet Scheme(P3, w));
	/* The following function, found in the file
	backgroundFunctions.magma  returns the lines in P3 which lie on 
	the scheme X: w^2-q(x,y,z). */
	lines, L := findLines(C);
	
	if #lines ne 56 then
		print "Error: not all lines found";
		return [0], Rationals();
	end if;
	return lines, L;
end function;


/* The following is either borrowed from or inspired by the code 
of Samir Siksek which is available at
http://homepages.warwick.ac.uk/~maseap/arith/notes/quartic.magma
more information on the functions and variables below is 
available in this file. */

findH1 := function(lines, L)
	numlines := #lines;
	if numlines ne 56 then
		return lines, L, [0], 0;
	end if;
	/* First we need the automorphism group of L. */
	G, _, permToAut := AutomorphismGroup(L, Rationals());
	/* GalAction is the permutation group of G acting on the 
	lines in list. */
	GalAction := PermutationGroup<numlines | 
		[LAction(permToAut(sig), lines): sig in Generators(G)]>;
	/* Next we construct the intersection matrix, as we will need
	it to compute the lattice in the Picard group generated by the 
	given lines. Each line has self intersection -1, so we start
	there. */
	Int := -1*IdentityMatrix(Integers(),numlines);
	/* Otherwise the intersection number of a pair of lines is the 
	degree of their intersection, 0, 1 or 2. */
	for i,j in [1..numlines] do
		if i ne j then
			intersect := lines[i] meet lines[j];
			if Dimension(intersect) eq 0 then
				Int[i,j] := Degree(intersect);
			end if;
		end if;
	end for;
	/* Build the module given by GalAction acting on Z^numlines */
	LambdaMod := PermutationModule(GalAction, Integers());
	Lambda := VectorSpace(LambdaMod); 
	/* Equivalence in the Picard group of a del Pezzo surface 
	is the same as linear equivalence.  Hence Pic is the quotient
	of Z^56 by the kernel of the intersection matrix. */
	Pic, class := quo< Lambda | Kernel(Int) >;
	ClassMatrix := Matrix([ class(Lambda.i) : i in [1..numlines]]);
	ClassSection := Solution(ClassMatrix, 
		IdentityMatrix(Integers(), Ncols(ClassMatrix)));
	/* We finally build the Picard group with action from the 
	Galois group */
	PicMod := GModule(GalAction, [ ClassSection * M *
		ClassMatrix :  M in ActionGenerators(LambdaMod) ] );
	if #GalAction eq 1 then
		H1 := 0;
	else
		CM := CohomologyModule(GalAction, PicMod);
		H1 := CohomologyGroup(CM, 1);
	end if;
	return lines, L, H1, GalAction;
end function;

findH1WithoutLines := function(q)
	lines, L := findLines(q);
	return findH1(lines, L);
end function;

findH1WithLines := function(lines, L)
	_, _, H1, GalAction := findH1(lines, L);
	return H1, GalAction;
end function;

